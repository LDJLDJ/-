### TCP的主要特点

-----------------
特点：  
（1）TCP是面向连接的运输层协议。即通信双方建立TCP连接，为接下来的数据传送做好准备，初始化各种状态变量，分配缓存等资源。完成传送后，需要释放连接。  
（2）每一条TCP连接只能有两个端点，即只能点对点（一对一）。一条TCP连接由两个套接字地址标识（IP地址、端口号）。  
（3）TCP提供可靠交付的服务。即TCP连接传送的数据无差错、不丢失、不重复，并且按序到达。  
（4）TCP提供全双工通信。TCP连接的两端设有发送缓存和接收缓存，用于临时存放双向通信的数据。  
（5）面向字节流。TCP中的**流**指的是流入到进程或从进程流出的字节序列。TCP的交互是一次一个数据块（大小不一），但TCP把从应用程序脚下来的数据看成  
一连串的无结构字节流。TCP不保证接收方所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。虽然大小不一定相同，但字节流完全一样。  

过程：  
（1）发送方的应用进程按照自己产生数据的规律(数据块长短不一)陆续写入TCP缓存。  
（2）TCP从缓存中取出一定数量的数据，组成TCP报文段逐个传送到IP层，然后发送出去。  
（3）接收方从IP层收到TCP报文后，暂存在缓存中，等待接收方的应用进程从接收缓存中按数据顺序读取。  

```
注意：  
接收方应用进程不是一次读取接收缓存中一个完整的报文和所有数据，是按照应用进程指定的数量读取数据。
只有接收缓存中的数据量小于指定读取量，才返回缓存中所有数据。  
如果缓存中没有数据，应用进程可能一直等待，也可能直接返回。
```

<img src="./imgs/TCP发送报文段的示意图.png" width="800" height="400"  alt="TCP发送报文段的示意图" >

TCP连接是一条虚连接，非物理连接，是抽象的逻辑连接。  
TCP连接仅存在两个端系统，而中间设备（路由器、交换机等）不知道该连接的存在。  
与UDP端口队列不同的是，TCP的发送缓存和接收缓存都是分配给一个连接的，而不是一个端口。TCP一个连接由四元组（源IP地址、源端口号、目的IP地址、目的端口）
标识。  
不同源TCP报文段、即使目的IP地址和目的端口号相同，它们在不同的TCP“管道”中传输，到达不同出口的缓存。  

### TCP报文段的格式 

------------------

<img src="./imgs/TCP报文段的格式.png" width="800" height="400"  alt="TCP报文段的格式" >

TCP虽然是面先字节流的，但TCP传送的数据单元却是报文段。  
TCP报文首部前20个字节是固定的，后面有4N个字节根据需要添加（N为整数）。  
首部各字段意义：  
（1）源端口和目的端口：各占2字节，该字段定义了主机发送和接收该报文段的应用程序的端口号，用于运输层的复用和分用。  
（2）序号：占4字节，序号从0开始，到2的32次幂-1为止，共2的32次幂个需要（4294967296）。值本报文段所发送的数据的第一个字节的序号。  
例：一段报文序号  字段值为301，携带的数据共100字节，表明：本报文段的第一个字节序号为301，最后一个序号为400，下一段报文从401开始。  
（3）确认号：占4字节，指期望收到对方的下一个报文段的第一个数据字节的序号。   
例：B收到A发来的一端报文段，序号为501，数据长度为200，这数据为501-700。因此，下一次B期望A发送的数据报序号是701，所有确认号位701。  
（4）数据偏移：占4位，指数据部分在TCP报文段的位置（即TCP报文首部的长度。），因为存在可选项，长度不固定，所以这个字段是必须的。  
因为4位二进制最大值为15（1111），因此数据偏移的最大值为60字节（宽为4个字节，15乘4=60）。  
（5）保留：占6位，保留为今后使用，目前为0。  
（6）紧急URG：当URG=1时，表明紧急指针字段有效。（高优先级的数据，不需要按序从接收缓存中读取）。  
（7）确认ACK：只有当ACK=1时确认号字段才有效。=0时，确认号无效。  
（8）推送PSH：发送方TCP把PSH置为1时，立即创建一个报文段发送出去，不需要积累足够多的数据再发送。  
接收方TCP收到PSH为1的报文段，尽快交付给接收应用进程，不需要等待足够多的数据才向上交付。  
应用程序可以选择推送操作，但现在多数TCP可以根据情况自动设置PSH。  
（9）复位RST：当RST=1时，表面TCP连接出现严重差错（主机奔溃等情况），释放连接，然后重写建立运输连接。还可以用来拒绝非法的报文段或连接。  
（10）同步SYN：用来建立连接。当SYN=1和ACK=0时，表明这是一个连接请求报文段。若对方同意，则应回复报文SYN=1和ACK=1。  
（11）终止FIN：释放一个连接，当FIN=1，表明该报文段的发送方数据已发送完毕，要求释放运输连接。  
（12）窗口：占2字节，窗口值指该报文段一方的接收窗口的大小，在0到2的16次幂-1之间。  
窗口用于控制对方发送的数据量（从确认号开始，允许对方发送的数据量）。计算机网络经常用接收方的接收能力来控制发送方的数据量。    
例：确认号为701，窗口字段为1000，则表明对方发送的数据范围为701-1700。  
（13）检验和：占2字节，检验范围为首部和数据。在计算检验和时，像UDP一样，加入12字节的伪首部，TCP协议为6。长度更改为TCP长度。  
（14）选项：长度可变，
1、最大报文段长度MMS：=TCP报文段长度-TCP首部长度。MMS过长（需要在IP层分组）或过短（需要在IP层填充）都会增大开销。默认MMS为536字节长，即报536+20=556长。    
2、窗口扩大选项：占 3 字节，其中有一个字节表示移位值 S。新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。  
3、时间戳选项：占10 字节，其中最主要的字段时间戳值字段（4 字节）和时间戳回送回答字段（4 字节）  
4、选择确认选项：在下方  

### TCP的可靠传输

----------------
TCP中如何实现可靠传输的，并注意与GBN协议的不同：  
（1）数据编号与确认：  
1、TCP是面向字节的，TCP把应用层交下来的数据看作是一个个字节的数据流，并使每个字节对应一个序号。（GBN协议中是对每个分组进行编号）  
2、TCP采用的是累积确认，即确认对所有按序接收到的数据的确认。  
例：接收方已收到1-700号，801-1000号和1201-1500号，而701-800和1001-1200号每首到，则发送的确认序号应填入701  
3、TCP发送一段报文时，同时在自己的重传队列中存放这个报文段的一个副本。若收到确认，删除此副本。若在规定时间内没收到确认，则重传。  
4、TCP采用全双工通信，因此通信中每方都不需要专门发送确认报文段，而可以在传送数据时顺带把确认信息**捎带**传送。  
接收方在正确收到数据时可能等待一般不超过0.5s再发送确认。若这段时间内有数据发送给对方，这捎带确认。  
也可能这段时间又有多段数据达到，则可以对这多次的数据进行累积确认。  
5、接收方收到有差错的报文段就丢弃（不发送否认信息）。若收到重复报文段，丢弃，但要立即发回确认信息。  
6、若收到的报文段无差错，只是为按序号顺序到达，（GBN协议会把所有不按序的报文段丢弃）TCP会先暂存在接收缓存中，待所缺序号到齐一起交付应用层。  
7、TCP发送方每发送一个报文段，就会为这个报文段设置一个计时器。只要计时器设置的重传时间到了没收到确认就重传这段报文段。  
（某个报文段超时，GBN则发送窗口欸所有已发送的分组。）  

（2）以字节为单位的滑动窗口：  

<img src="./imgs/TCP中的窗口概念.png" width="800" height="400"  alt="TCP中的窗口概念" >

<img src="./imgs/TCP中的窗口概念2.png" width="800" height="400"  alt="TCP中的窗口概念2" >

1、为了提高报文段的传输效率，TCP采用滑动窗口协议。（GBN是发送的单位是分组数）TCP发送窗口大小的单位是字节。  
2、发送窗口的大小是从建立连接时在TCP可选报文中填写的数据，这个值会随接收方的接收能力决定。  
3、已发送并确认的字节会发送到应用程序并从发送缓存中删除。  
如果TCP发送方速度过快，最终会导致发送缓存被填满，这时发送应用程序必须等待，直到发送缓存可以再次工作。  
4、接收方收到的分组有差错则丢弃，如果接收方缓存被填满则把窗口减少到0.如果应用程序能即使读取缓存中数据，窗口则增大，但不能超过缓存大小。  
```
需要强调三点:
A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。
TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。
TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。
``` 

（3）超时重传时间的选择：  
1、TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。  
2、TCP 保留了 RTT 的一个加权平均往返时间 RTTS（这又称为平滑的往返时间）。  
第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：  
新的 RTTS =(1-a) x (旧的 RTTS) + a x (新的 RTT 样本)，若a很接近于零，表示 RTT 值更新较慢。若选择a接近于 1，则表示 RTT 值更新较快。a建议取1/8     
3、超时重传时间 RTO ：RTO 应略大于上面得出的加权平均往返时间 RTTS。RFC 2988 建议使用下式计算 RTO：RTO = RTTS + 4 x RTTD  
RTTD 是 RTT 的偏差的加权平均值。第一次测量时，RTTD 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTTD  
新的 RTTD = (1 - b) x (旧的RTTD) + b x |RTTS - 新的 RTT 样本|(b 是个小于 1 的系数，其推荐值是 1/4，即 0.25)

<img src="./imgs/收到的确认是对哪一个报文段的确认.png" width="800" height="400"  alt="收到的确认是对哪一个报文段的确认" >

4、TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。  
如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？   
如果收到的确认是重传报文段2的确认，但却被源站当成报文段1的确认，那么计算出来的RTTS和超时重传时间就会偏大，  
如果收到的确认是报文1的确认，但却被源站当成重传报文2的确认，那么计算出来的RTTS和超时重传时间就会偏小。这就必然导致更多的重传报文。  
因此：  
Karn 算法：新的 RTO = r x (旧的 RTO)。系数 r 的典型值是 2。  
当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。  

（4）快速重传：
超时触发存在一个问题就是超时时间相对较长。超时重传时间RTO往往比实际的往返时间大很多。  
因此，快速重传是基于当一个报文段丢失后，发送方会发送多个重复的确认，通过收到多个重复的确认可以快速判断报文段已经丢失而不用等到重传超时时间。  
这是对超时触发重传的补充和改进。  

<img src="./imgs/快速重传的示意图.png" width="800" height="400"  alt="快速重传的示意图" >

当M2在网络拥塞中丢失了，由于使用TCP积累确认，所以M3、M4、M5都无法发送确认自己，只能发送确认M1。  
当发送方一连收到3个重复的M1确认后，就知道了M2丢失了，则再重传。  

（5）选择确认SACK：  
因为使用TCP累积确认，只通告了收到的最后一个按序到达的字节，没有收到失序到达的字节。发送方没有接受到失序字节的确认，则会重传。  
为了避免不必要的开销，使用选择确认SACK。  
例子：假设接收方收到了1-1000，1501-2000，2501-4000，缺失1001-1500和字节2001-2500。因为是两个失序字节块，所以需要四个边界序号来表示  
建立TCP连接时，双方还要在SYN报文和SYN+ACK报文段的首部选项中添加“允许SACK选项字段”，表示支持选择确认功能。  

### TCP的流量控制

----------------
为了解决发送方发送数据太快而导致接收方来不及接收，使接收方缓存溢出的问题。  
流量控制的基本方法就是接收方根据自己的接收能力控制发送方的发送速率。  
在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限。可动态调整对方的发送窗口上限值。发送窗口应该小于该值。  

<img src="./imgs/利用可变窗口进行流量控制举例.png" width="800" height="400"  alt="利用可变窗口进行流量控制举例" >

当接收方的可用接收缓存大小不再为0时，向发送方发送的窗口更新报文丢失了怎么办？  
为防止发送方一直等到死锁。窗口变为0时，如果发送方有数据要发送，则会周期性（如60s）发送只含有1个字节数据的**窗口探测**报文段，以便强制接收方发回确认并通告接收窗口大小。  
如果这时接收窗口大小非0，则会接收这个字节并对该字节进行确认，否则丢弃并对以前的数据进行重复确认。  


### TCP的连接管理

----------------
1、建立连接：  
TCP的标志规定，SYN=1的报文段（如A发送的第一个报文段）不能携带数据，但要消耗一个序号。  
因此A发送的第二个报文段的序号应该是第一个报文段序号+1（虽然报文1中无数据）  
A发送的第二个报文段中SYN是0，ACK位必须是1。该报文段是对B的同步报文段的确认，是一个普通报文段，可携带数据。  
若该报文段不携带数据，则按照TCP的规定，确认报文段不消耗序号。  

<img src="./imgs/用三次联络建立TCP连接.png" width="800" height="400"  alt="用三次联络建立TCP连接" >

<img src="./imgs/用三次握手建立 TCP 连接的各状态.png" width="800" height="400"  alt="用三次握手建立 TCP 连接的各状态" >

为什么要发送这第三个报文段呢？  
答：  
这主要是为了防止已失效的连接请求报文段突然又传送到了主机B，因而导致错误产生。  

“已失效的连接请求报文段”如何产生？  
答：  
主机A发出连接请求，但因连接请求报文在某些网络结点中滞留时间太长导致延误而未收到确认。  
A再次重传一次。后来受到了确认，建立了连接。释放连接。  
这时，延误的第一次连接到达了主机B，主机B误以为主机A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。
主机A由于没有要求建立连接，因此不会理睬主机B的确认，也不会向主机B发送数据。  
但主机B却以为运输连接就这样建立了，并一直等待主机A发来数据。主机B浪费了许多资源。  

2、释放连接：  
通信的双方都可以发出释放连接的请求
假设主机A的应用进程先向TCP发出连接释放请求，并且不再发送数据。把发往主机B的报文段首部FIN设置为1，序号seq=u。  
由于FIN报文段要消耗一个序号，因此序号等于A前面已传送过的数据的最后一个字节的序号+1。 

<img src="./imgs/TCP连接释放的过程.png" width="800" height="400"  alt="TCP连接释放的过程" >

<img src="./imgs/TCP连接释放的过程1.png" width="800" height="400"  alt="TCP连接释放的过程1" >

半关闭状态，相当于A向B说：“我已经没有数据发送了，如果你有，仍然可以发送给我，我仍可以接收”。  
此后，主机B不再接收A发来的数据。但若主机B还有数据发送给A，则可以继续发送。主机A只要正确受到数据，仍应给主机B发送确认。  
若主机B不再向主机A发送数据，则应用进程就通知TCP释放连接，如果箭头2。序号w（若半关闭状态下B没有发送数据，则w=v）。  

主机A并不能马上释放整个连接还要再等待一个超时时间才能释放连接，为什么？
答：    
因为主机A的确认有可能丢失，这时B会重传FIN报文段。  
在这段超时时间内，若A又收到B重传的FIN报文段，A需要再进行确认。收到A最后的确认，B才能最终将整个连接释放。  
若等待时间内没收到B的FIN报文，主机A的TCP则向其应用进程报告，整个连接已经全部释放。  

3、TCP的有限状态机：    
粗实线箭头表示对客户进程的正常变迁。  
粗虚线箭头表示对服务器进程的正常变迁。  
另一种细线箭头表示异常变迁。  

<img src="./imgs/TCP的有限状态机.png" width="800" height="400"  alt="TCP的有限状态机" >





